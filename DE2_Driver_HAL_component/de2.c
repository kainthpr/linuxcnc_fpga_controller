/* Autogenerated by /usr/bin/halcompile on Sun Sep 27 18:28:19 2020 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

// me
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <linux/if_packet.h>
#include <linux/if_ether.h>
#include <net/ethernet.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <time.h>
#include <stdlib.h>

#define ETHER_TYPE 0x80ab /* custom type */
#define BUF_SIZE 512

static char broadcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

char *msg;
int fd;
int count;
int if_index;
uint8_t if_addr[ETH_ALEN];
uint8_t dest_addr[ETH_ALEN];
int send_len = 64;
unsigned char buf[BUF_SIZE];
unsigned char rx_buf[BUF_SIZE];
int i;
struct ether_header *eh;
// me

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:de2:");
MODULE_INFO(linuxcnc, "param:sg0_scale:float:0:rw::4064.0:None");
MODULE_INFO(linuxcnc, "param:sg1_scale:float:0:rw::4064.0:None");
MODULE_INFO(linuxcnc, "param:sg2_scale:float:0:rw::4064.0:None");
MODULE_INFO(linuxcnc, "param:sg3_scale:float:0:rw::4064.0:None");
MODULE_INFO(linuxcnc, "param:sg4_scale:float:0:rw::4064.0:None");
MODULE_INFO(linuxcnc, "param:pwm_freq:float:0:rw::1000:None");
MODULE_INFO(linuxcnc, "pin:sg0_position_fb:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:sg0_velocity_cmd:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg0_enable:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg1_position_fb:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:sg1_velocity_cmd:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg1_enable:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg2_position_fb:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:sg2_velocity_cmd:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg2_enable:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg3_position_fb:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:sg3_velocity_cmd:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg3_enable:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg4_position_fb:float:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:sg4_velocity_cmd:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:sg4_enable:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:spindle_rpm:float:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:gpio_out-#:bit:32:in::None:None");
MODULE_INFO(linuxcnc, "pin:gpio_in-#:bit:32:out::None:None");
MODULE_INFO(linuxcnc, "funct:do_work:1:");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_float_t *sg0_position_fb;
    hal_float_t *sg0_velocity_cmd;
    hal_bit_t *sg0_enable;
    hal_float_t *sg1_position_fb;
    hal_float_t *sg1_velocity_cmd;
    hal_bit_t *sg1_enable;
    hal_float_t *sg2_position_fb;
    hal_float_t *sg2_velocity_cmd;
    hal_bit_t *sg2_enable;
    hal_float_t *sg3_position_fb;
    hal_float_t *sg3_velocity_cmd;
    hal_bit_t *sg3_enable;
    hal_float_t *sg4_position_fb;
    hal_float_t *sg4_velocity_cmd;
    hal_bit_t *sg4_enable;
    hal_float_t *spindle_rpm;
    hal_bit_t *gpio_out[32];
    hal_bit_t *gpio_in[32];
    hal_float_t sg0_scale;
    hal_float_t sg1_scale;
    hal_float_t sg2_scale;
    hal_float_t sg3_scale;
    hal_float_t sg4_scale;
    hal_float_t pwm_freq;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void do_work(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int j = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    r = hal_pin_float_newf(HAL_OUT, &(inst->sg0_position_fb), comp_id,
        "%s.sg0-position-fb", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->sg0_velocity_cmd), comp_id,
        "%s.sg0-velocity-cmd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->sg0_enable), comp_id,
        "%s.sg0-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->sg1_position_fb), comp_id,
        "%s.sg1-position-fb", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->sg1_velocity_cmd), comp_id,
        "%s.sg1-velocity-cmd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->sg1_enable), comp_id,
        "%s.sg1-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->sg2_position_fb), comp_id,
        "%s.sg2-position-fb", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->sg2_velocity_cmd), comp_id,
        "%s.sg2-velocity-cmd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->sg2_enable), comp_id,
        "%s.sg2-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->sg3_position_fb), comp_id,
        "%s.sg3-position-fb", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->sg3_velocity_cmd), comp_id,
        "%s.sg3-velocity-cmd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->sg3_enable), comp_id,
        "%s.sg3-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_OUT, &(inst->sg4_position_fb), comp_id,
        "%s.sg4-position-fb", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->sg4_velocity_cmd), comp_id,
        "%s.sg4-velocity-cmd", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->sg4_enable), comp_id,
        "%s.sg4-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_float_newf(HAL_IN, &(inst->spindle_rpm), comp_id,
        "%s.spindle-rpm", prefix);
    if(r != 0) return r;
    for(j=0; j < (32); j++) {
        r = hal_pin_bit_newf(HAL_IN, &(inst->gpio_out[j]), comp_id,
            "%s.gpio-out-%01d", prefix, j);
        if(r != 0) return r;
    }
    for(j=0; j < (32); j++) {
        r = hal_pin_bit_newf(HAL_OUT, &(inst->gpio_in[j]), comp_id,
            "%s.gpio-in-%01d", prefix, j);
        if(r != 0) return r;
    }
    r = hal_param_float_newf(HAL_RW, &(inst->sg0_scale), comp_id,
        "%s.sg0-scale", prefix);
    inst->sg0_scale = 4064.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->sg1_scale), comp_id,
        "%s.sg1-scale", prefix);
    inst->sg1_scale = 4064.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->sg2_scale), comp_id,
        "%s.sg2-scale", prefix);
    inst->sg2_scale = 4064.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->sg3_scale), comp_id,
        "%s.sg3-scale", prefix);
    inst->sg3_scale = 4064.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->sg4_scale), comp_id,
        "%s.sg4-scale", prefix);
    inst->sg4_scale = 4064.0;
    if(r != 0) return r;
    r = hal_param_float_newf(HAL_RW, &(inst->pwm_freq), comp_id,
        "%s.pwm-freq", prefix);
    inst->pwm_freq = 1000;
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s.do-work", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))do_work, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}


// me
    static char *if_name;
    RTAPI_MP_STRING(if_name, "name of ethernet interface. e.g. eth0");
    unsigned int pwm_counter;
// me
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("de2");
    if(comp_id < 0) return comp_id;
    r = export("de2", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
     // me 2
    // disabling ipv6 on this interface to avoid multicast spam
    char cmd[100];
     sprintf(cmd, "/sbin/sysctl -q net.ipv6.conf.%s.disable_ipv6=1",if_name);
    system(cmd);
    
    
	memcpy (dest_addr, broadcast_addr, ETH_ALEN);
	msg = "Hello";

	fd = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (fd == -1) {
	  perror("socket");
	  exit(1);
	}


	struct ifreq ifr;
	size_t if_name_len = strlen(if_name);
	if (if_name_len < sizeof(ifr.ifr_name)) {
		memcpy(ifr.ifr_name, if_name, if_name_len);
		ifr.ifr_name[if_name_len] = 0;
	}
	else {
		fprintf(stderr, "interface name is too long\n");
		exit(1);
	}
	if (ioctl(fd,SIOCGIFINDEX, &ifr) == -1) {
		perror("ioctl");
		exit(1);
	}
	int ifindex=ifr.ifr_ifindex;

	if (ioctl (fd, SIOCGIFHWADDR, &ifr) == -1){
		perror ("SIOCGIFHWADDR");
		exit(1);
	}

	memcpy (if_addr, ifr.ifr_hwaddr.sa_data, ETH_ALEN);

	struct sockaddr_ll addr = {0};
	addr.sll_family = AF_PACKET;
	addr.sll_ifindex = ifindex;
	addr.sll_protocol = htons(ETH_P_ALL);

	if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) {
		perror("bind");
		exit(1);
	}

	struct packet_mreq mreq = {0};
	mreq.mr_ifindex = ifindex;
	mreq.mr_type = PACKET_MR_PROMISC;
	if (setsockopt(fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &mreq, sizeof(mreq)) == -1) {
		perror("setsockopt");
		exit(1);
	}

	memset (buf, 0, BUF_SIZE);
	/* Construct ehternet header. */
	{
		/* Ethernet header */
		eh = (struct ether_header *) buf;
		memcpy (eh->ether_shost, if_addr, ETH_ALEN);
		memcpy (eh->ether_dhost, dest_addr, ETH_ALEN);
		eh->ether_type = htons (ETHER_TYPE);
	}
	
    // me 2
    
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef sg0_position_fb
#define sg0_position_fb (*__comp_inst->sg0_position_fb)
#undef sg0_velocity_cmd
#define sg0_velocity_cmd (0+*__comp_inst->sg0_velocity_cmd)
#undef sg0_enable
#define sg0_enable (0+*__comp_inst->sg0_enable)
#undef sg1_position_fb
#define sg1_position_fb (*__comp_inst->sg1_position_fb)
#undef sg1_velocity_cmd
#define sg1_velocity_cmd (0+*__comp_inst->sg1_velocity_cmd)
#undef sg1_enable
#define sg1_enable (0+*__comp_inst->sg1_enable)
#undef sg2_position_fb
#define sg2_position_fb (*__comp_inst->sg2_position_fb)
#undef sg2_velocity_cmd
#define sg2_velocity_cmd (0+*__comp_inst->sg2_velocity_cmd)
#undef sg2_enable
#define sg2_enable (0+*__comp_inst->sg2_enable)
#undef sg3_position_fb
#define sg3_position_fb (*__comp_inst->sg3_position_fb)
#undef sg3_velocity_cmd
#define sg3_velocity_cmd (0+*__comp_inst->sg3_velocity_cmd)
#undef sg3_enable
#define sg3_enable (0+*__comp_inst->sg3_enable)
#undef sg4_position_fb
#define sg4_position_fb (*__comp_inst->sg4_position_fb)
#undef sg4_velocity_cmd
#define sg4_velocity_cmd (0+*__comp_inst->sg4_velocity_cmd)
#undef sg4_enable
#define sg4_enable (0+*__comp_inst->sg4_enable)
#undef spindle_rpm
#define spindle_rpm (0+*__comp_inst->spindle_rpm)
#undef gpio_out
#define gpio_out(i) (0+*(__comp_inst->gpio_out[i]))
#undef gpio_in
#define gpio_in(i) (*(__comp_inst->gpio_in[i]))
#undef sg0_scale
#define sg0_scale (__comp_inst->sg0_scale)
#undef sg1_scale
#define sg1_scale (__comp_inst->sg1_scale)
#undef sg2_scale
#define sg2_scale (__comp_inst->sg2_scale)
#undef sg3_scale
#define sg3_scale (__comp_inst->sg3_scale)
#undef sg4_scale
#define sg4_scale (__comp_inst->sg4_scale)
#undef pwm_freq
#define pwm_freq (__comp_inst->pwm_freq)


#line 41 "de2.comp"
float pos;
int error_count;

FUNCTION(do_work){ 
	float thr = 1e-5;
	float sg0_velocity;
	int sg0_dir;
	
	float sg1_velocity;
	int sg1_dir;
	
	float sg2_velocity;
	int sg2_dir;
	
	float sg3_velocity;
	int sg3_dir;
	
	float sg4_velocity;
	int sg4_dir;
	
	
	// SG0 DIR and VEL
	if (sg0_velocity_cmd > 0)
	{
		sg0_dir = 1;
		sg0_velocity = sg0_velocity_cmd;
	}
	else
	{
		sg0_dir = 0;
		sg0_velocity = sg0_velocity_cmd * -1;
	}
	if (sg0_velocity < 0.01) // 10 milli inch / sec
	{
		sg0_velocity = 0;
		sg0_dir = 0;
	}
		// SG1 DIR and VEL
	if (sg1_velocity_cmd > 0)
	{
		sg1_dir = 1;
		sg1_velocity = sg1_velocity_cmd;
	}
	else
	{
		sg1_dir = 0;
		sg1_velocity = sg1_velocity_cmd * -1;
	}
	if (sg1_velocity < 0.01) // 10 milli inch / sec
	{
		sg1_velocity = 0;
		sg1_dir = 0;
	}
		// SG2 DIR and VEL
	if (sg2_velocity_cmd > 0)
	{
		sg2_dir = 1;
		sg2_velocity = sg2_velocity_cmd;
	}
	else
	{
		sg2_dir = 0;
		sg2_velocity = sg2_velocity_cmd * -1;
	}
	if (sg2_velocity < 0.01) // 10 milli inch / sec
	{
		sg2_velocity = 0;
		sg2_dir = 0;
	}
		// SG3 DIR and VEL
	if (sg3_velocity_cmd > 0)
	{
		sg3_dir = 1;
		sg3_velocity = sg3_velocity_cmd;
	}
	else
	{
		sg3_dir = 0;
		sg3_velocity = sg3_velocity_cmd * -1;
	}
	if (sg3_velocity < 0.01) // 10 milli inch / sec
	{
		sg3_velocity = 0;
		sg3_dir = 0;
	}
		// SG4 DIR and VEL
	if (sg4_velocity_cmd > 0)
	{
		sg4_dir = 1;
		sg4_velocity = sg4_velocity_cmd;
	}
	else
	{
		sg4_dir = 0;
		sg4_velocity = sg4_velocity_cmd * -1;
	}
	if (sg4_velocity < 0.01) // 10 milli inch / sec
	{
		sg4_velocity = 0;
		sg4_dir = 0;
	}
	
	// sg0 velocity
	int per = ((50e6/ (sg0_velocity*sg0_scale*2))-1);  // calculate the register period 
	buf[14] = per&0xFF;
	buf[15] = (per&0xFF00) >> 8;
	buf[16] = (per&0xFF0000) >> 16;
	buf[17] = (per&0xFF000000) >> 24;
	// sg1 velocity
	per = ((50e6/ (sg1_velocity*sg1_scale*2))-1);  // calculate the register period 
	buf[18] = per&0xFF;
	buf[19] = (per&0xFF00) >> 8;
	buf[20] = (per&0xFF0000) >> 16;
	buf[21] = (per&0xFF000000) >> 24;
	// sg2 velocity
	per = ((50e6/ (sg2_velocity*sg2_scale*2))-1);  // calculate the register period 
	buf[22] = per&0xFF;
	buf[23] = (per&0xFF00) >> 8;
	buf[24] = (per&0xFF0000) >> 16;
	buf[25] = (per&0xFF000000) >> 24;
	// sg3 velocity
	per = ((50e6/ (sg3_velocity*sg3_scale*2))-1);  // calculate the register period 
	buf[26] = per&0xFF;
	buf[27] = (per&0xFF00) >> 8;
	buf[28] = (per&0xFF0000) >> 16;
	buf[29] = (per&0xFF000000) >> 24;
	// sg4 velocity
	per = ((50e6/ (sg4_velocity*sg4_scale*2))-1);  // calculate the register period 
	buf[30] = per&0xFF;
	buf[31] = (per&0xFF00) >> 8;
	buf[32] = (per&0xFF0000) >> 16;
	buf[33] = (per&0xFF000000) >> 24;
	
	buf[34] = ((sg2_enable << 7) | (sg1_enable << 6) | (sg0_enable << 5) | (sg4_dir << 4) | (sg3_dir << 3) | (sg2_dir << 2) | (sg1_dir << 1) | sg0_dir);
	buf[35] = ((sg4_enable << 1) | (sg3_enable)); // the rest of the bits are spare;
	// buf[36], buf[37] are spares
	
	// buf[38] -> buf[41] = pwm counter
	// buf[42] -> buf[45] = pwm capture
	
	pwm_counter = (50e6/pwm_freq);  // only needs to do this once

	buf[38] = pwm_counter&0xFF;
	buf[39] = (pwm_counter&0xFF00) >> 8;
	buf[40] = (pwm_counter&0xFF0000) >> 16;
	buf[41] = (pwm_counter&0xFF000000) >> 24;
	
	float spindle_rpm_abs;
	if (spindle_rpm < 0)
	{
		spindle_rpm_abs = spindle_rpm * (-1);
	}
	else
	{
		spindle_rpm_abs = spindle_rpm;
	}
	unsigned int pwm_capture = spindle_rpm_abs*pwm_counter;  // rpm is 0 - 1
	//printf("%u, %u\n", pwm_counter, pwm_capture);
	buf[42] = pwm_capture&0xFF;
	buf[43] = (pwm_capture&0xFF00) >> 8;
	buf[44] = (pwm_capture&0xFF0000) >> 16;
	buf[45] = (pwm_capture&0xFF000000) >> 24;
	
	// o_gpio  46 to 49  
	unsigned int opins = 0;
	int i =0;
	for (i = 0; i<32; i++)
	{
		opins = opins | (gpio_out(i) << i);
	}
	buf[46] = opins&0xFF;
	buf[47] = (opins&0xFF00) >> 8;
	buf[48] = (opins&0xFF0000) >> 16;
	buf[49] = (opins&0xFF000000) >> 24;
	
	if (send (fd, buf, send_len, 0) < 0)
    perror ("sendto()");
    memset (rx_buf, 0, BUF_SIZE);
    
    int received = recvfrom (fd, rx_buf, BUF_SIZE, 0, NULL, NULL);
    if (received <= 0)
	{
		printf("recieve failed %d", received);
      return;
	}
	
	if (rx_buf[12] != 0x08 || rx_buf[13] != 0xab)
	{
		error_count++;
		printf("header: %X %X %d\n", rx_buf[12], rx_buf[13], error_count);
		return;
	}
	// i_gpio
	unsigned int ipins = (rx_buf[17] << 24) | (rx_buf[16] << 16) | (rx_buf[15] << 8) | (rx_buf[14]);
	for (i = 0; i<32; i++)
	{
		gpio_in(i) = ((ipins >> i) & (1));
	}
	
	// sg0 location 
	unsigned int steps = (rx_buf[21] << 24) | (rx_buf[20] << 16) | (rx_buf[19] << 8) | (rx_buf[18]);
	int loc = steps - 0x80000000;
	pos = loc/sg0_scale;
	sg0_position_fb = pos;
	
	// sg1 location 
	steps = (rx_buf[25] << 24) | (rx_buf[24] << 16) | (rx_buf[23] << 8) | (rx_buf[22]);
	loc = steps - 0x80000000;
	pos = loc/sg1_scale;
	sg1_position_fb = pos;
	
	// sg2 location 
	steps = (rx_buf[29] << 24) | (rx_buf[28] << 16) | (rx_buf[27] << 8) | (rx_buf[26]);
	loc = steps - 0x80000000;
	pos = loc/sg2_scale;
	sg2_position_fb = pos;
	
	// sg3 location 
	steps = (rx_buf[33] << 24) | (rx_buf[32] << 16) | (rx_buf[31] << 8) | (rx_buf[30]);
	loc = steps - 0x80000000;
	pos = loc/sg3_scale;
	sg3_position_fb = pos;
	
	// sg4 location 
	steps = (rx_buf[37] << 24) | (rx_buf[36] << 16) | (rx_buf[35] << 8) | (rx_buf[34]);
	loc = steps - 0x80000000;
	pos = loc/sg4_scale;
	sg4_position_fb = pos;
}


static int __comp_get_data_size(void) { return 0; }
